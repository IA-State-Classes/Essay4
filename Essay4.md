### PyPDF2 and PdfMiner comparison

A software developer, depending on what they want to do, has several options in terms of what library they want to use. They may want to develop a game, so they may use a library tailored to that goal. However, there are many libraries available for a type of goal. If a developer wishes to use a library to process PDF files (in python), they can choose between several libraries. Two of these libraries are PyPDF2 and pdfMiner.

PyPDF2 is a library with many different iterations, where the maintenance of this iteration was taken over by Martin Thoma in April of 2022. Furthermore, issues are found and resolved fairly regularly with this library. Currently, pyPDF2 supports python versions 3.6 - 3.10 and with previous versions of the library (PyPDF2 1.20.0 - 1.28.4) supporting python version 2.7 (along with the previously mentioned versions). With PyPDF2, a developer can merge pdf files, extract text and metadata, write to pdf files, and transform the contents of a PDF file. 

PdfMiner has two iterations, pdfMiner and pdfMiner.six. For this essay, PdfMiner will reference the pdfMiner.six iteration because it is more recently maintained. Issues are found and resolved similarly to pyPDF2. Currently, this library supports python versions 3.6 or newer. With PdfMiner, a developer can extract text, metadata, and images from a PDF file.  

#### Deployment View 
Both PyPDF2 and PdfMiner are pure python libraries, so they go through similar phases throughout their deployment processes: they both use [flake8](https://flake8.pycqa.org/en/latest/) to check the coding style, both run Continuous Integration (CI) workflow, and they both publish to Python Package Index (PyPI). However, there are still some nuances that leave one approach more desirable than the other in certain aspects.  

To start, unlike PdfMiner, PyPDF2 uses [pre-commit](https://pre-commit.com/) hooks for linting the changes even before the commits happen. However, PdfMiner partly makes up for it by using [black](https://black.readthedocs.io/en/stable/) to check and fix the code formatting during its workflow execution. In terms of their CI pipelines, each project has its own set of jobs it runs. PyPDF2's pipeline consists of 4 jobs including testing for core functionalities with [pytest](https://docs.pytest.org/en/7.2.x/), building and verifying packages with [flit](https://flit.pypa.io/en/stable/), checking for code coverage using [Coverage.py](https://coverage.readthedocs.io/en/6.5.0/), and benchmarking pypdf with [pytest](https://docs.pytest.org/en/7.2.x/). While PdfMiner's workflow does not check for code coverage or benchmark the library, it has its own qualities, including checking for code formatting and style with black and [flake8](https://flake8.pycqa.org/en/latest/), static type inspection using [mypy](http://mypy-lang.org/), and testing the documentation build with [sphinx](https://www.sphinx-doc.org/en/master/index.html).  

The two projects also have distinct publishing approaches to PyPI. Where PdfMiner automates the deployment inside its CI/CD workflow, PyPDF2 requires the maintainer - Martin Thoma - manually upload the package using the project [Makefile](https://github.com/py-pdf/PyPDF2/blob/main/Makefile).

#### Runtime View
PyPDF2 and PdfMiner are both libraries that accomplish the same goal of transforming the contents of pdf files. They both do not utilize a user interface to accomplish the goal. Instead, the contents of the library can be implemented into a python program that you write at the time of use. The requirement of the user to write the code makes both projects easier to develop and makes them both less prone to errors and bugs.

Many of the classes in PyPDF2 do not depend on each other. They can be used independently based on the task you are trying to execute, such as reading or writing to a pdf file. If I wanted to read a pdf file, I would never interact with the files or functionality that writes to pdf files. This is similar to PdfMiner but in a different way. Because the functionality of PdfMiner is not as complex, all of the functionality is focused on text/image extraction. This is intended to be done primarily with the use of the scripts included in the project's repository. 

Another way that the applications differ is in their modularity. In PyPDF2 most of the data structures and reading functionality is stored outside of PdfReader.py. In PdfMiner, these data structures and much of the pdf logic is actually stored in the pdf reader class. This modularity currently works for the scope of the project. As the project expands and adds functionality for different use cases, I would recommend that the community moves this logic outside to class to reduce the probability of bugs and simplify the code base.

### Usability
Usability is about how the user can use the software efficiently, effectively, and satisfactory with its intended purpose. Both PYPDF2 and pdf miner are about creating PDF documents. As usability is about the effectiveness of the software, that would go into the positives and negatives of both PYPDF and pdf miner. First, the benefits of PYPDF2 are that it allows the users to customize the pdf document by being allowed to split, merge, crop, and encrypt the pdf document. A negative about the software is that when the pdf document is created, there are spaces at unusual spaces. Along with that, PYPDF2 was shut down for a certain amount of time due to the creation of new versions of the software. There was a third and fourth version ( PYPDF3 and PYPDF4), but they didn't fix all the problems the software had and eventually, PYPDF2 was reactivated. This software's effectiveness as the improved versions did not fix all the problems and the earlier version had to be reactivated. With pdf miner, it allows the same functionalities as PYPDF2. A negative is that it does not have enough documentation, which is important for the user to understand how to use the software. 

