### PyPDF2 and PdfMiner comparison

A software developer, depending on what they want to do, has several options in terms of what library they want to use. They may want to develop a game, so they may use a library tailored to that goal. However, there are many libraries available for a type of goal. If a developer wishes to use a library to process PDF files (in python), they can choose between several libraries. Two of these libraries are PyPDF2 and pdfMiner.

PyPDF2 is a library with many different iterations, where the maintenance of this iteration was taken over by Martin Thoma in April of 2022. Furthermore, issues are found and resolved fairly regularly with this library. Currently, pyPDF2 supports python versions 3.6 - 3.10 and with previous versions of the library (PyPDF2 1.20.0 - 1.28.4) supporting python version 2.7 (along with the previously mentioned versions). With PyPDF2, a developer can merge pdf files, extract text and metadata, write to pdf files, and transform the contents of a PDF file. 

PdfMiner has two iterations, pdfMiner and pdfMiner.six. For this essay pdfMiner will reference the pdfMiner.six iteration because it is more recently maintained. Issues are found and resolved similarly to pyPDF2. Currently, this library supports python versions 3.6 or newer. With PdfMiner a developer can extract text, metadata, and images from a PDF file.  

#### Deployment View 
Both PyPDF2 and PdfMiner are pure python libraries, so they go through similar phases throughout their deployment processes: they both use [flake8](https://flake8.pycqa.org/en/latest/) to check the coding style, both run Continuous Integration (CI) workflow, and they both publish to Python Package Index (PyPI). However, there are still some nuances that leave one approach more desirable than the other in certain aspects.  

To start, unlike PdfMiner, PyPDF2 uses [pre-commit](https://pre-commit.com/) hooks for linting the changes even before the commits happen. However, PdfMiner partly makes up for it by using [black](https://black.readthedocs.io/en/stable/) to check and fix the code formatting during its workflow execution. In terms of their CI pipelines, each project has its own set of jobs it runs. PyPDF2’s pipeline consists of 4 jobs including testing for core functionalities with [pytest](https://docs.pytest.org/en/7.2.x/), building and verifying packages with [flit](https://flit.pypa.io/en/stable/), checking for code coverage using [Coverage.py](https://coverage.readthedocs.io/en/6.5.0/), and benchmarking pypdf with [pytest](https://docs.pytest.org/en/7.2.x/). While PdfMiner’s workflow does not check for code coverage or benchmark the library, it has its own qualities including checking for code formatting and style with black and [flake8](https://flake8.pycqa.org/en/latest/), static type inspection using [mypy](http://mypy-lang.org/), and testing the documentation build with [sphinx](https://www.sphinx-doc.org/en/master/index.html).  

The two projects also have distinct publishing approaches to PyPI. Where PdfMiner automates the deployment inside its CI/CD workflow, PyPDF2 requires the maintainer - Martin Thoma - manually upload the package using the project [Makefile](https://github.com/py-pdf/PyPDF2/blob/main/Makefile).

#### Runtime View
PyPDF2 and PdfMiner are both libraries that accomplish the same goal of transorming the contents of pdf files. They both do not utilize a user interface to accomplish the goal. Instead, the contents of the library can be implemented into a python program that you write at the time of use. The reqirment of the user to write the code makes both projects easier to develop and make them both less prone to errors and bugs.

Many of the classes in PyPDF2 do not depend on each other. They can be used independently based on the task you are trying to execute such as read or writing to a pdf file. The same can't be said about PdfMiner. In PdfMiner, most of the casses have several dependencies. For example, if I wanted to convert a .pdf file to .txt format, I would use the pdf2txt.py that uses and handles many data structures within the .pdf format. PyPDF2 does this all externally to the file, and does not require that you understand this part of the prject when doing simple functions like this.

### Usability
Usability is about how the user can use the software efficiently, effectively, and satisfactory with its intended purpose. Both PYPDF2 and pdf miner are about creating PDF documents. As usability is about the effectiveness of the software that would go into the positives and negatives of both PYPDF and pdf miner. First, the benefits of PYPDF2 are that it allows the users to customize the pdf document by being allowed to split, merge, crop, encrypt the pdf document. A negative about the software is that when the pdf document is created there are spaces at unusual spaces. Along with that, PYPDF2 was shut down for a certain amount of time due to the creation of new versions of the software. There was a third and fourth version ( PYPDF3 and PYPDF4), but they didn’t fix all the problems the software had and eventually PYPDF2 was reactivated. This software’s effectiveness as the improved versions did not fix all the problems and the earlier version had to be reactivated. With pdf miner it allows the same functionalities as PYPDF2. A negative is that it does not have enough documentation which is important for the user to understand how to use the software. 


