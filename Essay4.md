### PyPDF2 and PdfMiner comparison

A software developer, depending on what they want to do, has several options in terms of what library they want to use. They may want to develop a game, so they may use a library tailored to that goal. However, there are many libraries available for a type of goal. If a developer wishes to use a library to process PDF files (in python), they can choose between several libraries. Two of these libraries are [PyPDF2](https://github.com/py-pdf/PyPDF2) and [pdfMiner](https://github.com/pdfminer/pdfminer.six).

PyPDF2 is a library with many different iterations, where the maintenance of this iteration was taken over by Martin Thoma in April of 2022. Furthermore, [issues](https://github.com/py-pdf/PyPDF2/issues) are found and resolved fairly regularly with this library. Currently, pyPDF2 supports python versions 3.6 - 3.10, and with previous versions of the library (PyPDF2 1.20.0 - 1.28.4) support python version 2.7 (along with the previously mentioned versions). With PyPDF2, a developer can merge pdf files, extract text and metadata, write to pdf files, and transform the contents of a PDF file. 

PdfMiner has two iterations, pdfMiner and pdfMiner.six. For this essay, PdfMiner will reference the pdfMiner.six iterations because it is more recently maintained. [Issues](https://github.com/pdfminer/pdfminer.six/issues) are found and resolved similarly to pyPDF2. Currently, this library supports python versions 3.6 or newer. With PdfMiner, a developer can extract text, metadata, and images from a PDF file.  

The overall progress of these libraries is in very different places. The functionality of PyPDF2 is extreme. PyPDF2 is able to split, merge, crop, and transform the pages of PDF files. It can also add custom data, viewing options, and passwords to PDF files. PyPDF2 can retrieve text and metadata from PDFs as well. This library covers all bases very well. If you have a need, there is a good chance that this project is able to complete your goal. As for PdfMiner, the functionality is implemented to a much lesser extent. For example, the only use cases that PdfMiner is able to accomplish are extracting text from a pdf file and extracting other objects, such as images, from a pdf file. This functionality covers a very specific use case when it comes to pdf files.

Both projects overall have been in production for quite some time. Which each project has its flaws, both set out to accomplish different goals when it comes to dealing with the binary behind a pdf file. Many of the differences in the projects have to do with how they approach the problem when it comes to software development. These differences are in development characteristics and views of the characteristics, such as the deployment view, the runtime view, and overall project usability.

#### Deployment View 
Both PyPDF2 and PdfMiner are pure python libraries, so they go through similar phases throughout their deployment processes: they both use [flake8](https://flake8.pycqa.org/en/latest/) to check the coding style, both use `ubuntu-latest` to run Continuous Integration (CI) workflow, and they both publish to Python Package Index (PyPI). However, there are still some nuances that leave one approach more desirable than the other in certain aspects.  

To start, unlike PdfMiner, PyPDF2 uses [pre-commit](https://pre-commit.com/) hooks for linting the changes even before the commits happen. However, PdfMiner partly makes up for it by using [black](https://black.readthedocs.io/en/stable/) to check and fix the code formatting during its workflow execution. In terms of their CI pipelines, each project has its own set of jobs it runs. PyPDF2's pipeline consists of 4 jobs, including testing for core functionalities with [pytest](https://docs.pytest.org/en/7.2.x/), building and verifying packages with [flit](https://flit.pypa.io/en/stable/), checking for code coverage using [Coverage.py](https://coverage.readthedocs.io/en/6.5.0/), and benchmarking pypdf with [pytest](https://docs.pytest.org/en/7.2.x/). While PdfMiner's workflow does not check for code coverage or benchmark the library, it has its own qualities, including checking for code formatting and style with [black](https://black.readthedocs.io/en/stable/) and [flake8](https://flake8.pycqa.org/en/latest/), static type inspection using [mypy](http://mypy-lang.org/), and testing the documentation build with [sphinx](https://www.sphinx-doc.org/en/master/index.html).  

Despite both libraries verifying their functional tests using various python versions - from 3.6 to 3.11 - PyPDF2 still does a better job at testing thanks to its `sample-files` directory. On top of checking for core aspects like reading, writing, merging, etc. the directory contains a collection of testing documents that cover wide range of edge cases that the ordinary tests do not check for. The two projects also have distinct publishing approaches to PyPI. Where PdfMiner automates the deployment inside its CI/CD workflow, PyPDF2 requires the maintainer - Martin Thoma - manually upload the package using the project [Makefile](https://github.com/py-pdf/PyPDF2/blob/main/Makefile). 

#### Runtime View
PyPDF2 and PdfMiner are both libraries that accomplish the same goal of transforming the contents of pdf files. They both do not utilize a user interface to accomplish the goal. Instead, the contents of the library can be implemented into a python program that you write at the time of use. The requirement of the user to write the code makes both projects easier to develop and makes them both less prone to errors and bugs.

Many of the classes in PyPDF2 do not depend on each other. They can be used independently based on the task you are trying to execute, such as reading or writing to a pdf file. If I wanted to read a pdf file, I would never interact with the files or functionality that writes to pdf files. This is similar to PdfMiner but in a different way. You will never in fact have to interact with pdf writing because the functionality of PdfMiner does not exist. PdfMiner is not as complex, and all of the functionality is focused on text/image extraction. This is intended to be done primarily with the use of the scripts included in the project's repository.

Another way that the applications differ is in their modularity. In PyPDF2, most of the data structures and binary conversions are stored outside of PdfReader.py. In PdfMiner, these data structures and most of the logic is actually stored inside the pdf reader class. This modularity currently works for the scope of the project. As the project expands and adds functionality for different use cases, the community should move this logic outside to class to reduce the probability of bugs and simplify the code base.

### Usability
Usability is about how the user can use the software more efficiently and effectively for a given task. Both PYPDF2 and pdf miner are about transforming and scanning PDF documents. PyPDF2 and PdfMiner use roughly the same user interface. Both projects expect the user to know Python well enough to implement their respective libraries. Where PyPDF2 leaves implementation totally up to the user, PdfMiner gives some guidance and scripts that you can copy and run yourself. The scripts that they give only require slight modification to the code allowing for a wider variety of users for the library. This is one way that PyPDF2 is lacking. It does not provide files in the repo to copy and use for myself. Instead, PyPDF2 has extensive documentation for countless functions of the library.